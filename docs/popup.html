<!DOCTYPE html>
<html>

<head>
    <title>Popup Window</title>
    <link rel="stylesheet" href="utils/codemirror.css" />
    <link rel="stylesheet" href="utils/darkmode.css" />
    <script src="utils/beautify.js"></script>
    <script src="utils/uglify.js"></script>
    <script src="utils/prettier.js"></script>
    <script src="utils/babelParser.js"></script>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }

        .cm-editor {
            height: 100%;
        }
    </style>
</head>

<body>
    <textarea id="popupEditor"></textarea>

    <script type="module">
        import { basicSetup, EditorView } from "./utils/codemirror.js"
        import { autocompletion } from "./utils/@codemirror-autocomplete.js"
        import { javascript, scopeCompletionSource, javascriptLanguage } from "./utils/@codemirror-lang-javascript.js"
        import { oneDark } from "./utils/one-dark.js"
        window.test2 = javascriptLanguage;
        const completions = [
            { label: "update", apply: "this.update = function() {\n\n}", type: "macro" },
            { label: "display", apply: "this.display = function() {\n\n}", type: "macro" },
            { label: "draw", apply: "this.draw = function() {\n\n}", type: "macro" },
            { label: "init", apply: "this.init = function() {\n\n}", type: "macro" },
            { label: "park", type: "constant", info: "Test completion" },
        ]

        function myCompletions(context) {
            let before = context.matchBefore(/\w+/)
            // If completion wasn't explicitly started and there
            // is no word before the cursor, don't open completions.
            if (!context.explicit && !before) return null
            return {
                from: before ? before.from : context.pos,
                options: completions,
                validFor: /^\w*$/
            }
        }
        globalThis.engine = {
            scene: [],currentScene: 0,files: {},uuidList: {},usedUUID: [],hasUUID: false,assignedUUID: "",world: {},componentList: {},removeListeners: [],physics: false,errorText: "",zoom: 1,camera: {},gui: {},mobile: false,guiObjects: {},Initiate:()=>{},activeScene:()=>{},addObj:()=>{},addScriptByName:()=>{},assignUUID:()=>{},cameraPos:()=>{},changeUUID:()=>{},constructor:()=>{},customDraw:()=>{},customFileUUID:()=>{},deleteGameFile:()=>{},deviceMoved:()=>{},deviceShaken:()=>{},deviceTurned:()=>{},doubleClicked:()=>{},draw:()=>{},generateUUID:()=>{},getActiveScene:()=>{},getByReference:()=>{},getfromUUID:()=>{},keyPressed:()=>{},keyReleased:()=>{},keyTyped:()=>{},loadFromObject:()=>{},mouseClicked:()=>{},mouseDragged:()=>{},mouseMoved:()=>{},mousePressed:()=>{},mouseReleased:()=>{},mouseScreen:()=>{},mouseWheel:()=>{},resize:()=>{},setup:()=>{},touchEnded:()=>{},touchMoved:()=>{},touchStarted:()=>{},updateGui:()=>{},activeScene:()=>{},cameraPos:()=>{},cameraPos:()=>{},}
        let parser = javascript()
        parser.allowNesting = true;
        window.test = parser
        document.addEventListener("keydown", function (event) {
            if ((event.ctrlKey || event.metaKey) && event.key === "s") {
                event.preventDefault();
                sendTextToMainWindow();
            }
        });
        function editorFromTextArea(textarea, extensions) {
            let view = new EditorView({
                doc: textarea.value, extensions: [
                    basicSetup,
                    parser,
                    oneDark
                ],
                mode: "javascript",
                parent: document.body
            })
            textarea.parentNode.insertBefore(view.dom, textarea)
            textarea.style.display = "none"
            if (textarea.form) textarea.form.addEventListener("submit", () => {
                textarea.value = view.state.doc.toString()
            })
            return view
        }

        var editor = editorFromTextArea(document.getElementById("popupEditor"));
        function receivePopupText() {
            var text = window.opener.scriptData();
            var beautifiedText = js_beautify(text, {
                indent_size: 2,
            }); // Beautify the text
            editor.setValue(beautifiedText);
        }

        function sendTextToMainWindow() {
            //prettier formats it as i like
            prettierPlugins.babel.parsers.parser =
                prettierPlugins.babel.parsers.babel.parse;
            prettierPlugins.babel.parsers.tabWidth = 0
            var text = editor.getValue();
            //Replace single lines into /**/ comments
            let regex = /(\/\/)(.*)/gm;
            text = text.replace(regex, '/*$2*/')
            var beautifiedText = js_beautify(text, {
                indent_size: 0, // Set indent size to 0
                space_in_empty_paren: true, // Preserve space in empty parentheses
                jslint_happy: true, // Use JSLint-compatible formatting
                keep_array_indentation: false, // Remove array indentation
                preserve_newlines: false, // Remove new lines
                semicolon_after_statement: true,
            });
            let toBeReviewed = beautifiedText;
            //TRUE semicolon after statement
            try {
                beautifiedText = prettier.format(
                    toBeReviewed,
                    prettierPlugins.babel.parsers
                );
                // Remove new lines
                removeNewLines = (beautifiedText.replace(/\r?\n|\r/g, ""));
                try {
                    let temp = { shown: {} };
                    (new Function(beautifiedText)).call(temp);
                    try {
                        window.opener.receivePopupText(removeNewLines);
                        receivePopupText()
                    } catch (error) {
                        alert("Couldn't send to window");
                        alert(error);
                        console.error(error);
                    }
                } catch (error) {
                    alert("script has typeerror:");
                    alert(error)
                }
            } catch (error) {
                alert("syntax mistake:" + error);
            }
        }
        receivePopupText();
    </script>
</body>

</html>